#!/usr/bin/python3
# OPBOT - Object Programming Bot (bin/opbot)
#
# this file is placed in the public domain

import os, sys ; sys.path.insert(0, os.getcwd())

import atexit
import os
import readline
import sys

from op.hdl import Command, Handler, cmd
from op.prs import parse_cli
from op.trm import termsave, termreset
from op.thr import launch
from op.utl import opcheck, privileges

wd = os.path.expanduser("~/.opbot")

class Console(Handler):

    def __init__(self):
        super().__init__()
        self.register("cmd", cmd)

    def announce(self, txt):
        self.direct(txt)

    def direct(self, txt):
        print(txt)

    def input(self):
        while 1:
            try:
                e = self.poll()
            except EOFError:
                break
            self.put(e)
            e.wait()

    def poll(self):
        return Command(input("> "))

    def say(self, channel, txt):
        self.direct(txt)

    def start(self):
        super().start()
        launch(self.input)

class Mini(Handler):

    def direct(self, txt):
        print(txt)

def console(main):
    termsave()
    try:
        main()
    except KeyboardInterrupt:
        print("")
    except PermissionError as ex:
        print(str(ex))
    finally:
        termreset()

def daemon():
    pid = os.fork()
    if pid != 0:
        termreset()
        os._exit(0)
    os.setsid()
    os.umask(0)
    si = open("/dev/null", 'r')
    so = open("/dev/null", 'a+')
    se = open("/dev/null", 'a+')
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

def main():
    privileges("opbot")
    cfg = parse_cli(wd)
    if opcheck("b", cfg)  and not cfg.txt:
        daemon()
    c = Console()
    c.load("op.cmd")
    c.walk("opmod,opbot")
    if cfg.txt:
        h = Mini()
        h.clone(c)
        return h.cmd(cfg.otxt)
    if opcheck("s", cfg):
        c.init("irc", "opbot")
        c.init(cfg.sets.mods, "opmod")
        c.start()
        c.wait()
 
console(main)
os._exit(0)
